fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n =fib(n-1) + fib(n-2) 


maximum' :: (Ord a) => [a] -> a
--The first pattern says that if the list is empty, the program should crash.
maximum' [] = error " empty list"
-- The second pattern says that if maximum' is passed a singleton list, it
--should just return that list’s only element.
maximum'[x] = x 
-- 1.Списъкът е разделен на head и tail
-- 2.Прилагаме функцията max 
-- (да припомним, че max взима 2 стойности и връща по-голямата от двете)

{-Ако x е по-голямо от най-големия елемент в xs,
нашата функция ще върне x, в противен случай ще върне най-големия елемент в xs.
Но как нашата функция „максимум“ намира най-големия елемент в xs? Просто – като извиква
себе си, рекурсивно!-}

maximum' (x:xs) = max x (maximum' xs)

{-Нека разгледаме този код с конкретен пример, в случай че имате проблеми с визуализирането на това как работи maximum'. Ако извикаме maximum' на [2,5,1],
първите два шаблона не съвпадат с извикването на функцията. Третият шаблон обаче съвпада, така че стойността от списъка се разделя на 2 и [5,1], а maximum' се извиква
с [5,1].-}

{-За това ново извикване на maximum', [5,1] съответства на третия шаблон и отново входният списък се разделя – този път на 5 и [1] – и maximum' 
се извиква рекурсивно на [1].Това е единичен списък, така че най-новото извикване сега съответства наедин от нашите базови случаи и връща 1 като резултат.
Сега се качваме с едно ниво нагоре, сравнявайки 5 с 1, използвайки функцията max.
1 беше резултат от последното ни рекурсивно извикване. Тъй като 5 е по-голямо, сега знаем, че максимумът на [5,1] е 5.-}


replicate' :: (Num i, Ord i) => i -> a -> [a]
replicate' n x 
    | n <= 0 = []
    | otherwise = x:replicate'(n-1) x

take' :: (Num i, Ord i) => i -> [a] -> [a]

take' n _ 
    | n <= 0 = []
take' _ [] = []
take' n (x:xs) = x : take' (n-1) xs
